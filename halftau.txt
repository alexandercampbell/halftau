
x : Int -> Int
x k = k + 1

fn x k

fn fold f l s $


fn reverse xs $
	concat (reverse $ tail xs) $ head xs



:: (Y -> Z) -> (X -> Y) -> (X -> Z)
comp f g $
	\x -> f $ g x


ns math

fn map [f xs] $

Num -> Int -> Num
pow x n $
	(assert- "Negative exponents not allowed" >= n 0)
	fold * 1 $ repeat n x

:: Int -> Int
factorial n $
	fold * 1 [1..n]

assert $ = 5 $ math/fact 3

fn dec x $ - x 1
fn inc x $ + x 1

(fn x [k] (k + 3))




mk-monster name position x y =
	{ name name
	, x x
	, y y
	}

my-monster = mk-monster "goblin" 32 32
monsters = [my-monster]
monsters_past_x10 = filter (\m $ > 10 m.x) monsters

inc x = + x 1
dec x = - x 1


fn inc x $ + x 1
fn dec x $ - x 1

fn xs [1 2 3 4]
fn double x $ * 2 x
fn doubled values $ map double values
fn doubled_xs $ doubled_values xs
assert $ = doubled_xs [2 4 6 8]


inc x = + x 1
dec x = - x 1
double x = * 2 x
double = * 2

doubled = map double
xs = [1 2 3 4]
doubled_xs = doubled xs

inc x = + x 1
dec x = - x 1
double x = * 2 x

xs = [1 2 3 4]
doubled_xs = double xs
double = * 2
triple = * 3
compose fn1 fn2 x = fn2 $ fn1 x
sextuple = compose double triangle


(def x (y z) (+ y z))
(assert (= ((x 1) 2) 3))

(def x (list y z) (+ y z))

name monster = monster.name

def x [y z] (+ y z)

def x [y z] $

assert $ = 3 $ x 1 2


---


if condition then else =
	condition ? then : else

new-square x y
	{ x, y }

def new-square [x y]
	{ x = x
	, y = y
	}

def update-square [square]
	square
	|> update
		{ x = + square.x 5
		, y = + square.y 5
		}

def init [] $
	{ squares =
		[ new-square 12 12
		, new-square 32 34
		]
	}



---

20190919

enum Maybe a
	= Just a
	| Nothing

enum Result a b
	= Err a
	| Ok b

head : [a] -> Maybe a
cons : a -> [a] -> [a]
show : a -> String
print : String -> IO
map : (a -> b) -> [a] -> [b]
filter (a -> Bool) -> [a] -> [a]
foldl : (b -> a -> b) -> b -> [a] -> b
foldr : (b -> a -> b) -> b -> [a] -> b


// example program

struct Model =
	{ x : Int
	}

update : Model -> Model
update model =
	{ model.x = + model.x 1 }

step : Model -> [IO]
step model =
	let
		model' = update model
		action = print $ concat ["hello, x is now ", show model.x, "\n"]
	in
		cons action $ step model'

main = step $ update $ Model { x = 1 }



---

the builtin runtime will iterate the output of main ([IO]) and execute each one
IO will be an opaque value
It will represent an instruction to the runtime to perform some action
now, how to handle input




struct Model =
	{ x : Int
	}

update : Model -> Model
update model =
	{ model.x = + model.x 1 }


typeclasses will probably be too challenging.


---

car, cdr, cons, quote, cond, atom, eq


head, tail, cons, empty, ', if, eq, lt, gt, ()

type Maybe a
	= Just a
	| Nothing

head     : [a] -> a
tail     : [a] -> [a]
empty 	 : [a] -> Bool
cons	 : a -> [a] -> [a]
add	 : Num -> Num -> Num
subtract : Num -> Num -> Num
mult	 : Num -> Num -> Num
div	 : Num -> Num -> Num
mod	 : Num -> Num -> Num

map : (a -> b) -> [a] -> [b]
map fn ls =
	if (= [] ls)
	[]
	(cons (fn $ head ls) $ map fn $ tail ls)

filter : (a -> Bool) -> [a] -> [a]
filter is-good ls =
	if (= [] ls) [] $
		if (is-good $ head ls)
			((cons $ head ls) $ filter is-good $ tail ls)
			$ filter is-good $ tail ls

times2 :: [Num] -> [Num]
times2 = map $ mult 2

times4 :: [Num] -> [Num]
times4 = map $ mult 4

plus1 :: [Num] -> [Num]
plus1 = map $ plus 1




